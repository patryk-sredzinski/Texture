//#!/usr/bin/swift

//
//  generate_spm_sources_layout.swift
//
//  Created by Petro Rovenskyy on 09.03.2021.
//
//  Swift Package Manager [has some strict requirements](https://github.com/apple/swift-package-manager/blob/main/Documentation/Usage.md#creating-c-language-targets) to source files layout.
//  We can gain SPM support with minimal project structure changes by applying an autogenerated layout based on symbolic links technics. 
//  SPM related files (public headers) located under `Texture/Source/include` folder.
//  SPM target which support IGListKit located under `Texture/AsyncDisplayKitIGListKit` folder which hold symbolic link to `Soure` folder.
//
//  You should **NEVER** modify it manually nor inlude to Xcode's project.

//   ### Generate SPM layout

//   1. From **project's root** run:

//     `swift scripts/generate_spm_sources_layout.swift`

//   2. Commit Changes

//   Repeate those steps each time you delete/add project's files. **Make sure** to have this CI step which will check that `generate_spm_sources_layout.swift` is not broken.

import Foundation

// MARK: Defines

struct SearchPath {
    enum SearchCfg: UInt8 {
        case currentDirOnly
        case includeSubirectories
    }
    let path: String
    let isDir: Bool
    let searchPattern: SearchCfg
    init(path: String,
         isDir: Bool,
         searchPattern: SearchCfg = .includeSubirectories) {
        self.path = path
        self.isDir = isDir
        self.searchPattern = searchPattern
    }
}

let exludeFilePaths: [SearchPath] = [
    .init(path: "Source/Classes/include", isDir: true),
    .init(path: "Source/include", isDir: true)
]

let publicHeadersLayout: [SearchPath] = [
    .init(path: "Source", isDir: true, searchPattern: .currentDirOnly),
    .init(path: "Source/Details", isDir: true),
    .init(path: "Source/Layout", isDir: true),
    .init(path: "Source/Base", isDir: true, searchPattern: .currentDirOnly),
    .init(path: "Source/Debug", isDir: true),
    .init(path: "Source/TextKit/ASTextNodeTypes.h", isDir: false),
    .init(path: "Source/TextKit/ASTextKitComponents.h", isDir: false),
    .init(path: "Source/TextExperiment/Component", isDir: true, searchPattern: .currentDirOnly),
    .init(path: "Source/TextExperiment/String/ASTextAttribute.h", isDir: false),
]

// MARK: Helpers

func headersOnlyFromCurrent(directory path: String) -> [String] {
    let fm: FileManager = FileManager.default
    let items: [String] = try! fm.contentsOfDirectory(atPath: path)
        .filter({ (path) -> Bool in
            return exludeFilePaths.contains(where: { (searchPath) -> Bool in
                return searchPath.path.contains(path)
            })
        })
        .filter({$0.hasSuffix(".h")})
        .compactMap({ (item) -> String in
            return path + "/" + item
        })
    return items
}

func headersIncludingSubdirectoriesFrom(directory path: String) -> [String] {
    let dirItems: FileManager.DirectoryEnumerator? = FileManager.default.enumerator(atPath: path)
    let sourceFilePaths: [String] = dirItems?.allObjects as! [String]
    var publicHeaders: [String] = []
    sourceFilePaths
        .filter({$0.hasSuffix(".h")})
        .forEach { (sourceItemPath) in
            let temp = path + "/" + sourceItemPath
            // Skip files if needed
            guard exludeFilePaths.allSatisfy({!temp.contains($0.path)}) else {
                return
            }
            // Validate that path make sence and file exists
            guard FileManager.default.fileExists(atPath: temp) else {
                fatalError("Could not find source file at path:\n \(path)")
            }
            publicHeaders.append(temp)
        }
    return publicHeaders
}

func cleanup() {
    let fm = FileManager.default
    do {
        let paths: [String] = try fm.contentsOfDirectory(atPath: spmIncludeFolder)
        for path in paths {
            try fm.removeItem(atPath: "\(spmIncludeFolder)/\(path)")
        }
    } catch {
        fatalError(error.localizedDescription)
    }
}

// MARK: Script start

let projectRoot: String = FileManager.default.currentDirectoryPath
let sourceFolder: String = projectRoot + "/"
let spmIncludeFolder: String = sourceFolder + "Source/include"

// 1. Delete all existing symlinks
cleanup()

// 2. Find all public headers
var publicHeaders: [String] = []
publicHeadersLayout.forEach { (headerLayout) in
    let fPath = sourceFolder + headerLayout.path
    // 2.1. Is it path to a file and not folder?
    // Just grab it.
    guard headerLayout.isDir else {
        assert(FileManager.default.fileExists(atPath: fPath),
               "Could not find source file at path:\n \(fPath)")
        publicHeaders.append(fPath)
        return
    }
    // 2.2. It's a folder path, search.
    switch headerLayout.searchPattern {
    case .currentDirOnly:
        let currentFolder = headersOnlyFromCurrent(directory: fPath)
        publicHeaders.append(contentsOf: currentFolder)
    case .includeSubirectories:
        let subfolders = headersIncludingSubdirectoriesFrom(directory: fPath)
        publicHeaders.append(contentsOf: subfolders)
    }
}

// 3. Create symbolic links to satisfy SPM layout
publicHeaders.forEach { (headerPath) in
    let name = URL(string: headerPath)!.lastPathComponent
    let path = spmIncludeFolder + "/" + name
    do {
        try FileManager.default.createSymbolicLink(atPath: path, withDestinationPath: headerPath)
    } catch {
        fatalError(error.localizedDescription)
    }
}

